#include "Projectile.h"
#include <cmath>
Projectile::Projectile(int newX, int newY, int newDamage, int newSpeed, Enemy* newEnemy, std::string textureReference)
: GameObject(newX, newY, textureReference),
  damage(newDamage), speed(newSpeed), enemy(newEnemy)
{
    setDirection(enemy);
}

/*bool Projectile::drawSprite(sf::RenderWindow& canvas) // Är redan implementerad i GameObject /T
{
   sprite.setPosition(xPos,xPos);
   canvas.draw(sprite);//game object always have a sprite
   return true;
}*/


int Projectile::getDamage() const
{
    return damage;
}

void Projectile::setDamage(int newDamage)
{
    damage = newDamage;
    return;
}

int Projectile::getSpeed() const
{
    return speed;
}

void Projectile::setSpeed(int newSpeed)
{
    speed = newSpeed;
    return;
}

int Projectile::getDirX() const
{
    return dirX;
}

int Projectile::getDirY() const
{
    return dirY;
}

void Projectile::setDirection(int newDirX, int newDirY)
{
    dirX = newDirX;
    dirY = newDirY;
    return;
}


void Projectile::setDirection(Enemy* aim)
{
    int enemyPosX;
    int enemyPosY;
    //double directionRatio;
    double directionAngle;
    //double PI = 3.14159265;

    if((enemy != NULL))
    {
        enemyPosX = enemy->getPosX();
        enemyPosY = enemy->getPosY();

        directionAngle = atan2(enemyPosX- xPos, enemyPosY-yPos);
        dirX = speed * cos(directionAngle) + 0.5;
        dirY = speed * sin(directionAngle) + 0.5;


        // Utkommenterat för att man borde kunna använda atan2 som över.
        // Plus att detta skjuter åt fel håll... =)
        /**
        directionRatio = (enemyPosY - yPos)/(enemyPosX - xPos);
        // Om fiende i projektils första kvadrant
        if ((directionRatio >= 0) && (enemyPosY >= yPos))
        {
            directionAngle = atan(directionRatio);
            dirX = speed * cos(directionAngle) + 0.5; // +0.5 För korrekt avrundning
            dirY = speed * sin(directionAngle) + 0.5; // +0.5 För korrekt avrundning
        }
        // Om fiende i projektils tredje kvadrant
        else if ((directionRatio >= 0) && (enemyPosY <= 0))
        {
            directionAngle = atan(directionRatio) + PI/2; // Atan -> vinkel i fjarde kvadranten, adderar därför Pi/2
            dirX = speed * cos(directionAngle) + 0.5; // +0.5 För korrekt avrundning
            dirY = speed * sin(directionAngle) + 0.5; // +0.5 För korrekt avrundning
        }
        //Om fiende i projektils andra kvadrant
        else if((directionRatio < 0) && (enemyPosY >= yPos))
        {
            directionAngle = atan(directionRatio) + PI/2; // Atan -> vinkel i fjarde kvadranten, adderar därför Pi/2
            dirX = speed * cos(directionAngle) + 0.5; // +0.5 För korrekt avrundning
            dirY = speed * sin(directionAngle) + 0.5; // +0.5 För korrekt avrundning
        }
        //Om fiende i projektils fjarde kvadrant
        else if((directionRatio < 0) && (enemyPosY <= yPos))
        {
            directionAngle = atan(directionRatio);
            dirX = speed * cos(directionAngle) + 0.5; // +0.5 För korrekt avrundning
            dirY = speed * sin(directionAngle) + 0.5; // +0.5 För korrekt avrundning
        }
        */
    }
    return;
}


void Projectile::move()//SFML's move fungerar som denna. använda den istället för setPosition?
{
    xPos = xPos + dirX;
    yPos = yPos +dirY;
    return;
}


void Projectile::setClosestEnemy(std::vector<Enemy*>& enemyVector)
{
    Enemy* closestEnemy = NULL;
    double closestRange = 0;
    double rangeToEnemy;

    if(!enemyVector.empty())
    {
        Enemy* closestEnemy = enemyVector[0];
        closestRange = sqrt(((enemyVector[0]->getPosX() - xPos)^2) + ((enemyVector[0]->getPosY() - yPos)^2));

        for (unsigned int i = 1; i < enemyVector.size(); ++i)
        {
            rangeToEnemy = sqrt(((enemyVector[i]->getPosX() - xPos)^2) + ((enemyVector[i]->getPosY() - yPos)^2));
            if (rangeToEnemy < closestRange)
            {
                closestRange = rangeToEnemy;
                closestEnemy = enemyVector[i];
            }
        }
    }

    enemy = closestEnemy;

    return;
}








